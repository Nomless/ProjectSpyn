TOUCH_PORT = 4;
ULTRASONIC_PORT = 1;
GYRO_PORT = 2;
COLOR_PORT = 3;
LEFT_DRIVE_MOTOR = 'D';
RIGHT_DRIVE_MOTOR = 'C';
ARM_MOTOR = 'B';

% 2 - Blue
% 3 - Green
% 4 - Yellow
% 5 - Red
STOP_COLOR = 5;
PICKUP_COLOR = 3;
DROPOFF_COLOR = 2;

DRIVE_SPEED = 60;
LEFT_OFFSET = 5;
TURN_SPEED = 100;

touched = false;

function ret = GetColor(brick, port)
    rgb = brick.ColorRGB(port);
    red = rgb(1);
    green = rgb(2);
    blue = rgb(3);
    magnitude = sqrt(double(red * red + green * green + blue * blue));
    if magnitude < 100
        ret = 0;
    elseif red > 100
        if green > 80
            ret = 4;
        else
            ret = 5;
        end
    elseif blue > 150
        ret = 2;
    elseif green > 115
        ret = 3;
    else
        ret = 0;
    end
end

function Turn(brick, gyro_port, left_port, right_port, target)
    % target angle is cw+
    angle = brick.GyroAngle(gyro_port);
    if isnan(angle)
        angle = 0;
    end
    error = target - angle;
    p = 600;
    %i = 0.01;
    t = 0;
    while abs(error) > 1 && t <= 2
        angle = brick.GyroAngle(gyro_port);
        error = target - angle;
        n_error = error / 360;
        out = clip(p * n_error, -100, 100);
        brick.MoveMotor(left_port, out);
        brick.MoveMotor(right_port, -out);
        t = t + 0.1;
        pause(0.1);
    end
    brick.StopMotor(left_port);
    brick.StopMotor(right_port);
    brick.GyroCalibrate(gyro_port);
end

function KeyboardControl(brick)
    global key
    InitKeyboard();
    
    while 1
        pause(0.1);
        switch key
            case 'w'
                disp("Up");
                brick.MoveMotor(LEFT_DRIVE_MOTOR, -speed);
                brick.MoveMotor(RIGHT_MOTOR, -speed);
            case 'a'
                disp('left');
                brick.MoveMotor(LEFT_MOTOR, speed);
                brick.MoveMotor(RIGHT_MOTOR, -speed);
            case 's'
                disp("down");
                brick.MoveMotor(LEFT_MOTOR, speed);
                brick.MoveMotor(RIGHT_MOTOR, speed);
            case 'd'
                disp('right');
                brick.MoveMotor(LEFT_MOTOR, -speed);
                brick.MoveMotor(RIGHT_MOTOR, speed);
            case 'q'
                disp('right');
                brick.MoveMotor(LEFT_MOTOR, -speed/2);
                brick.MoveMotor(RIGHT_MOTOR, -speed);
            case 'e'
                disp('right');
                brick.MoveMotor(LEFT_MOTOR, -speed);
                brick.MoveMotor(RIGHT_MOTOR, -speed/2);
            case 'uparrow'
                speed = speed + 10
            case 'downarrow'
                speed = speed - 10
            case 0
                brick.StopMotor(LEFT_MOTOR);
                brick.StopMotor(RIGHT_MOTOR);
            case 'p'
                break;
        end
    end
    brick.StopMotor(LEFT_MOTOR);
    brick.StopMotor(RIGHT_MOTOR);
    CloseKeyboard();
end

brick.GyroCalibrate(GYRO_PORT);
brick.SetColorMode(3, 4);

%brick.beep();

brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);

while 1
    if isnan(brick.TouchPressed(TOUCH_PORT))
        disp("NaN???");
        continue
    end
    if ~touched && brick.TouchPressed(TOUCH_PORT)
        disp("Touching wall");
        touched = true;
        brick.MoveMotor(LEFT_DRIVE_MOTOR, -DRIVE_SPEED);
        brick.MoveMotor(RIGHT_DRIVE_MOTOR, -DRIVE_SPEED);
        pause(0.5);
        brick.StopMotor(LEFT_DRIVE_MOTOR);
        brick.StopMotor(RIGHT_DRIVE_MOTOR);
        continue;
    end
    distance = brick.UltrasonicDist(ULTRASONIC_PORT);
    color = GetColor(brick, COLOR_PORT)
    if touched
        % move right
        Turn(brick, GYRO_PORT, LEFT_DRIVE_MOTOR, RIGHT_DRIVE_MOTOR, 90);
        touched = false;
        pause(0.5);
        brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
        brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
    elseif color ~= 0
        if color == STOP_COLOR
            brick.StopMotor(LEFT_DRIVE_MOTOR);
            brick.StopMotor(RIGHT_DRIVE_MOTOR);
            pause(1);
            brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
            brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
            pause(0.5);
        elseif color == PICKUP_COLOR
            brick.StopMotor(LEFT_DRIVE_MOTOR);
            brick.StopMotor(RIGHT_DRIVE_MOTOR);
            pause(1);
            brick.beep();
            pause(1);
            brick.beep();
            while GetColor(brick, COLOR_PORT) == PICKUP_COLOR
                pause(1);
            end
            brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
            brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
            pause(0.5);
        elseif color == DROPOFF_COLOR
            brick.StopMotor(LEFT_DRIVE_MOTOR);
            brick.StopMotor(RIGHT_DRIVE_MOTOR);
            pause(1);
            brick.beep();
            pause(1);
            brick.beep();
            pause(1);
            brick.beep();
            while GetColor(brick, COLOR_PORT) == DROPOFF_COLOR
                pause(1);
            end
            brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
            brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
            pause(0.5);
        end
    elseif distance > 40
        %pause(0.);
        % move left
        %brick.MoveMotor(LEFT_DRIVE_MOTOR, -DRIVE_SPEED);
        %brick.MoveMotor(RIGHT_DRIVE_MOTOR, -DRIVE_SPEED);
        %pause(0.25);
        Turn(brick, GYRO_PORT, LEFT_DRIVE_MOTOR, RIGHT_DRIVE_MOTOR, -95);
        pause(0.5);
        brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
        brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
        for i = 1:16
            if GetColor(brick, COLOR_PORT) == STOP_COLOR
                brick.StopMotor(LEFT_DRIVE_MOTOR);
                brick.StopMotor(RIGHT_DRIVE_MOTOR);
                pause(2);
                brick.MoveMotor(LEFT_DRIVE_MOTOR, DRIVE_SPEED + LEFT_OFFSET);
                brick.MoveMotor(RIGHT_DRIVE_MOTOR, DRIVE_SPEED);
                break;
            end
            pause(0.1);
        end
    end
    
    pause(0.1);
end